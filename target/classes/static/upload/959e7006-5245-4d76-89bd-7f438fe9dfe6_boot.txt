DI  / IOC


객체 생성

1. Anntation
   - @Component
   - @Repository
   - @Service
   - @Controller
   - @RestController
   - @ControllerAdvice

2. Java config
   - 	
	

객체 주입
@Autowired : 타입으로 inject, 타입이 같으면 이름으로 inject
	    : 이름은 별도 지정을 하지 않으면 클래스명의 첫글자를 소문자로 바꾼것이 이름으로 ..		

@Resource  : 이름으로 Inject (type이 틀리면 error)

 ex)
	@Component
	@Qualitifier("객체 생성시 이름")	

	@Autowired
	@Qualitifier("객체 생성시 이름")

	@Resource(name="객체 생성시 이름")

------------------------------------------------------------------------
	MyBatis 연동
1. DataSource 
	- HikariCP가 기본 제공 되고 있고 따로 Bean 생성 없이 기본 정보만 넣어 주면 객체가 생성 됌
	- SqlSessionTemplate, SqlSession은 기본 제공 되므로 생성 할 필요가 없음.
	---- application.properties
	### DataSource 설정
	spring.datasource.username=spring01
	spring.datasource.password=Root!234
	spring.datasource.url=jdbc:mysql://192.168.200.100:3306/spring01
	# --- mysql 8 
	spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

	# --- mysql 8 미만
	#spring.datasource.driver-class-name=com.mysql.jdbc.Driver
2. Mapper
   	- 파일 생성 위치
	---- src/main/resources 하위(추가 폴더 생성 가능)
	- 파일의 생성 위치에 상관 없이 ***Mapper.xml의 namespace의 값은
	  DAO(Mapper)의 풀패키지명.클래스명과 동일하게 작성
	- DAO(Mapper)의 메서드 명은 Mapper의 id명과 동일하게 작성

3. application.properties 파일에 Mapper.xml과 Config.xml의 파일 위치 등록
	- ## My batis 설정
		mybatis.mapper-locations=classpath:/mybatis/**/*Mapper.xml
		mybatis.config-location=classpath:/mybatis/**/*Config.xml

4. DAO(Mapper)
	- 선언부에 @Mapper 선언

5. Mapper.xml을 DAO(Mapper)와 같은 패키지에 생성 가능
	- application.properties에 파일의 위치를 알려주는것을 생략


-------------------------------------------------------------------------
View(Jsp) 연결

1. application.properties
#### JSP
spring.mvc.view.prefix=WEB-INF/views
spring.mvc.view.suffix=.jsp

#### server port
server.port=80

2. JSP 에 대한 API 추가(pom.xml)
 
<!-- https://mvnrepository.com/artifact/org.apache.tomcat.embed/tomcat-embed-jasper -->
	<dependency>
	    <groupId>org.apache.tomcat.embed</groupId>
	    <artifactId>tomcat-embed-jasper</artifactId>
	</dependency>
	
<!-- https://mvnrepository.com/artifact/javax.servlet/jstl -->
	<dependency>
	    <groupId>javax.servlet</groupId>
	    <artifactId>jstl</artifactId>
	</dependency>

3. 개발자가 src/main/wepapp/WEB-INF/views 폴더 생성
    - 프로젝트 생성시에 Packaging을 war 선택해야 wepApp 폴더가 만들어짐
    - jar 선택시 wepApp폴더가 없음.

=====================================================
	FileUpload & DownLoad

1. Form 태그의 enctype의 속성을 multipart/form-data, method는 post
2. application.properties
	#### FileUpload
	## Multipart 사용 여부
	spring.servlet.multipart.enabled=true
	## 파일 하나 당 최대 크기
	spring.servlet.multipart.max-file-size=10MB
	## 총 파일의 최대 크기
	spring.servlet.multipart.max-request-size=100MB

3. Controller
	-- source code 참조

=================================================
	FileDownLoad

1. 다운로드 용 Custom View 생성

=========================================
AOP(Aspect Oriented Programming, 관점 지향 프로그래밍)

1. API (Pom.xml) 추가

	<!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-aop -->
	<dependency>
	    <groupId>org.springframework.boot</groupId>
	    <artifactId>spring-boot-starter-aop</artifactId>
	</dependency>

2. Main Method가 있는 Main Class
	클래스 선언부에 
	@EnableAspectJAutoProxy 선언(생략해도 잘 돌아감)

3. Aspect
	
@Component
@Aspect
public class CustomAOP {
	
	//@Before("execution(* com.iu.b1.member.MemberService.memberLogin(..))")
	public void before()throws Exception{
		System.out.println("Before MemberJoin");
	}
	
	@AfterReturning("execution(* com.iu.b1.member.MemberService.memberLogin(..))")
	public void afterReturning()throws Exception{
		System.out.println("After Returning");
	}
	
	@AfterThrowing("execution(* com.iu.b1.member.MemberService.memberJoin(..))")
	public void afterThrowing()throws Exception{
		System.out.println("After Throwing");
	}
	
	@After("execution(* com.iu.b1.member.MemberService.memberJoin(..))")
	public void after()throws Exception{
		System.out.println("After");
	}
	
	@Around("execution(* com.iu.b1.member.MemberService.memberLogin(..))")
	public Object around(ProceedingJoinPoint joinPoint)throws Throwable{
		System.out.println("메서드 실행전");
		
		Object obj = joinPoint.proceed();
		
		System.out.println("메서드 실행 후");
		
		return obj;
	}

}
================================================
Transaction
	1. Main Class 선언부
	   @EnableTransactionManagement 선언(생략 해도 무방)

	2. 필요한 곳에 @Transactional을 선언
	    - 메서드 선언부
	    - 클래스 선언부
	3. 혹시 에러 뜨면
	    - @Transactional(rollbackFor = Exception.class)
	    - 메서드가 public 이어야 함
	    - application.properties
		spring.aop.proxy-target-class=true 
		-- Service클래스에 @Transactional를 사용시
		-- Service클래스가 부모 인터페이스 없이 단독 사용할 때 에러 방지	

==================================================
	Interceptor

	1. HandlerInterceptorAdaptor를 구현
		preHandle
		postHandle
		afterCompletion,,

	2. Interceptor 등록
		source 코드 참조!!!

===========================================
	Message 다국어
	* src/main/resources 하위에 폴더나 파일을 생성
	* 한국어 ***_kr.properties 로 생성
	* 영어    ***_en.properties 로 생성
	*  기본 파일 ***.properties 로 생성

	ex) 
	1. src/main/resources/message/message_**.properties 
	2. application.properties
		#### message
		## message 파일의 위치를 지정
		spring.messages.basename=message/message
		spring.messages.encoding=UTF-8
		## 메시지가 없는 코드일 경우 예외를 발생
		## true  : 예외를 발생시키지 않고 코드를 출력
		## false : 예외를 발생
		spring.messages.use-code-as-default-message=true
		spring.messages.cache-duration=60

	3. JavaConfig 적용
		- 언어를 구분 하는 방법은 Cookie나 Session을 사용
		- Interceptor를 사용하여 언어별 메시지를 구분

	4. JSP
	<%@ taglib prefix="spring" uri="http://www.springframework.org/tags" %>		
	
	<spring:message code="properties의 키" text="키가 없을 경우 기본메시지"  >
		-- 속성
		---- code="properties의 키"
		---- text="키가 없을 경우 기본메시지"
		---- var="변수명" 	
		---- login.Message={0}환영합니다{1}
		---- arguments="${member.id}, ${member.email}" 
		---- argumentSeparator="," //arguments 구분자

===================================================
	Form 검증

	VO 검증
	Annotation을 이용한 검증
	VO의 멤버변수나 setter 적용

	- 검증 관련 Annotation
	A. Bean Validation 2.0 제공 Annotation
		@NotEmpty
		@NotNull
		@Max
		@Min
		@Size(min=, max=) //문자열 또는 배열의 길이도 가능	
		@AssertFalse
		@AssertTrue
		@DecimalMax(value = "") : 지정한 값 이하의 실수 여부
		@DecimalMinx(value = "") : 지정한 값 이상의 실수 여부
		@Digits()	: 정수 여부
		@Future(): 미래여부
		@Past()   : 과거 여부
		@pattern(regex="")	: 정규표현식

	B. Hibernate 제공 Annotation
		@Email
		@Length(min=, max=) : 문자열이 길이 검증
		@Range(min=, max=)  : 숫자 범위 검증
		@URL		     : URL 형식 검증

	2. JSP 
	<%@ taglib prefix="form" uri="http://www.springframework.org/tags/form" %>

	//modelAttribute  : Controller에서 Model에 추가한 Bean객체의 속성명
	<form:form modelAttribute="memberVO">
		//path : Bean의 멤버변수명. 일반 form 태그의 name의 역활
		<form:input path="id" />
		//검증 메세지를 출력하는 용도, 일반 css를 적용할 클래스명
		<form:errors path="id"  cssClass=""/>

	3. 검증 메세지
		1) 메세지 파일을 만들지 않으면 기본 메세지가 출력
		2) @NotEmpty(message = "ID는 비우면 안됌")
		3) message.properties 사용
			-- 기본설정은 message과 동일
		    	-- 작성 규칙
			 	검증Annotation명=메세지
				검증Annotation명.멤버변수명=메세지
				검증Annotation.VO명.멤버변수명=메세지

	4. 사용자 정의 검증 메서드 
	1) 검증할 코드 구현- code참조

========================================================
	정규표현식

	a		: 	a
	[abcd]		:	a또는 b 또는 c또는 d 중 하나
	[a-z]		:	a 부터 z 사이 중 하나
	[^abc]		:	a, b, c를 제외
	[a-zA-Z]		: 	a 부터 z 또는 A-Z 중 하나
	[a-zA-Z0-9]	:	모든 알파벳 모든 숫자
	[ㄱ-ㅎ가-힇]	:	모든 한글 문자	
	[[a-z]&&[^e-g]]	: 	a-z 중에서 e-g 제외	
	\d		:	digit, 모든 숫자	      [0-9]	
	\D		:	숫자를 제외한 모든 문자[^0-9]
	\s		:	공백 한칸을 의미
	\S		:	공백을 제외한 모든 문자 중 하나.
	\w		:	모든 영문자, 또는 숫자 [a-zA-Z0-9]
	\W		:	[^a-zA-Z0-9]
	^		: 	문자열의 시작을 의미 ex) ^abc- abc로 시작하는 문자열 : !=  [^abc]
	$		:	문자열의 끝을 의미    ex) abc$ - abc로 끝나는 문자열
	--------------------------------------------------
	+		:	1개 이상  ex) 	[abc]+	- abc중 1개 이상
	*		:	0개 이상
	?		:	0개 또는 1개
	{3, }		:	최소 3개 이상	\d{2,}	- 숫자가 최소 2개 이상
	{, 3}		:	최대 3개 이하
	{4, 8}		:	최소 4개 이상 최대 8개 이하
	***** {} 빈공간을 주면 X
	-------------------------------------------------------
	a | b		: or	
	.		: 존재하는 문자중 단 하나(임의의 한문자)
	\.		: . 을 의미






	






	







	











